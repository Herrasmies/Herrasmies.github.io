casino_simulator(900, 100, T, "med")
casino_simulator(900, 100, T, "high")
casino_simulator(900, 100, T, "high")
casino_simulator(900, 100, T, "high")
dev.off()
casino_simulator(900, 100, T, "high")
casino_simulator(1200, 100, T, "high")
casino_simulator(1200, 100, T, "med")
casino_simulator(1200, 100, T, "med")
casino_simulator(1200, 100, T, "med")
casino_simulator(1200, 100, T, "low")
library(tidyverse)
library(gganimate)
library(transformr)
library(truncnorm)
casino_simulator <- function(rounds, players, topbottom = F, volatility = "low") {
simulations = data.frame(nrow = 0)
if (volatility=="low") {
payout <- c(100, 50, 30, 15, 8, 7, 3, 2, 0) - 1
probability <- c(0.002, 0.011, 0.236, 1.151, 1.101, 1.123, 7.445, 12.928, 76.003)/100
ev <- sum(payout*probability) #ev = -0.10045
}
else if (volatility=="med") {
payout <- c(500, 65, 45, 13, 7, 6, 3, 2, 0) - 1
probability <- c(0.002, 0.011, 0.236, 1.151, 1.101, 1.123, 7.445, 12.928, 76.003)/100
ev <- sum(payout*probability) #ev = -0.10066
}
else {
payout <- c(2000, 50, 33, 14, 7, 5, 3, 2, 0) - 1
probability <- c(0.002, 0.011, 0.236, 1.151, 1.101, 1.123, 7.445, 12.928, 76.003)/100
ev <- sum(payout*probability) #ev = -0.10035
}
for (i in 1:players) {
test <- sample(payout, rounds, replace=TRUE, prob=probability)
test <- data.frame(run = test)
names(test)[1] <- i
simulations <- cbind(simulations, cumsum(test))
simulations$nrow <- NULL
}
max_value <- which(tail(simulations, 1) == max(tail(simulations, 1))) # Among the last row, which column has the highest value
min_value <- which(tail(simulations, 1) == min(tail(simulations, 1))) # Among the last row, which column has the lowest value
#How many are winning at the end
winners <- length(which(tail(simulations, 1) > 0))
simulations$ID <- seq.int(nrow(simulations))
simulations.long <- simulations %>%
gather(key, value, -ID)
#Upswing calculations using custom sliding-window regression (width-300 i.e. 1 hour)
simulations.long <- simulations.long %>% group_by(key) %>% dplyr::mutate(id = seq(1:n()))
upswing_detector <- function(window_width = 300, fidelity=1) { #window_width = 300 = 1 hour as a definition of upswing range
estimates_slope <- list()
counter = 0
for (x in 1:length(unique(simulations.long$key))) { #iterate through all players
for (i in seq(1, length(unique(simulations.long$id))+1-window_width, by = fidelity)) { #how many sliding windows fit within the sample, fidelity to speed calculation
temp <- subset(simulations.long, key==x & id >= i & id < i+window_width) #subset based on selected window width
temp_model <- lm(value ~ id, data=temp)
counter = counter + 1
estimates_slope[[counter]] <- coef(summary(temp_model))[2,1]
}
}
estimates_slope <- as.data.frame(unlist(estimates_slope))
estimates_slope <- estimates_slope %>%
dplyr::mutate(ID=rep(1:players, each=(length(unique(simulations.long$id))-window_width) / fidelity + 1)) # +1 before -window_width removed since otherwise doesn't work with fidelity=1 for some reason
names(estimates_slope)[1] <- "slope"
# Calculate proportion of upswings (vs. downswings) for all players, then obtain mean and sd across players, as well as maximum streak length with sd
output1 <- estimates_slope %>%
group_by(ID) %>%
dplyr::mutate(positive = ifelse(slope > 0, 1, 0),
run_length = rep(rle(positive)$lengths, rle(positive)$lengths)) %>%
dplyr::summarize(pos_prop = mean(positive),
max_run = max(run_length)) %>%
ungroup() %>%
dplyr::summarize(mean_grand_prop = mean(pos_prop),
sd_grand_prop = sd(pos_prop),
mean_run = mean(max_run),
sd_run = sd(max_run))
output2 <- estimates_slope %>%
group_by(ID) %>%
dplyr::mutate(numb = 1:n(), upswing = factor(ifelse(slope > 0, "Upswing", "Downswing"))) %>%
ggplot(aes(numb, slope, color=upswing)) +
geom_line(aes(group=1)) +
#facet_wrap("ID", scales="free") +
labs(color=NULL, x = "Hours played", y = "Slope") +
scale_color_manual(values=c("red", "blue")) +
scale_x_continuous(breaks = seq(0, (rounds-window_width)/10, by = 60),
labels=function(x)round(x/5/6 +1, 1)) + #+1 jotta saadaan tasattua normiplotin kanssa
theme_minimal(base_size=14) +
theme(legend.position="bottom")
output3 <- estimates_slope %>%
rename(key = ID) %>%
group_by(key) %>%
dplyr::mutate(key = as.character(key), ID = 1:n(), upswing = factor(ifelse(lag(slope, window_width/2) > 0, "Upswing", "Downswing")),
slope_corrected = lag(slope, window_width/2),
upswing_prop = mean(as.numeric(upswing)-1, na.rm=T)) #difficult to visualize upswings!! (this is not optimal, using lag() since the last 300 (window length) observations are missing by design)
#return(ggarrange(output2, plot3))
return(output3) #for colored visulaization of upswing
#return(output1) #for upswing proportion calculations
}
# !!!!!uncomment below to be able to use plot4!!!!!
#simulations.long <- simulations.long %>% left_join(upswing_detector())
#This was for testing whether the upswing detector works (un-comment below, and add "labs(title = output)" to plot3)
#output <- upswing_detector()
# Plot only the top and bottom "players"
# Note, for animations, the coloring is sensitive to alphabetical order of the key-factor labels!
plot2 <- simulations.long %>%
dplyr::filter(key == max_value | key == min_value) %>%
dplyr::mutate(key = factor(key, levels = c(max_value, min_value),
labels = c("Luckiest\nplayer", "Unluckiest\nplayer"))) %>%
ggplot(aes(ID, value, group=key)) +
geom_line(aes(colour = key)) +
geom_abline(intercept = 0, slope = ev, linetype="dashed", size=0.5, color="red", alpha=.5) +
geom_hline(yintercept = 0, size=0.5, alpha=.5) +
xlab("Hours played") + ylab("Money (euros)") +
theme_minimal(base_size=14) +
scale_x_continuous(breaks = seq(0, rounds, by = 600), # If <0 hour is visualized, the x-axis will not show correctly
labels=function(x)round(x/5/60, 1)) +
guides(color="none")
# Combined plot
# (code may fail if there are 3 or more identical values (shared bottom or top))
plot3 <- simulations.long %>%
dplyr::mutate(maxmin = case_when(key == max_value ~ "Luckiest\nplayer",
key == min_value ~ "Unluckiest\nplayer",
TRUE ~ "Others"),
maxmin = factor(maxmin, levels = c("Luckiest\nplayer", "Unluckiest\nplayer", "Others"))) %>%
ggplot(aes(ID, value, group=key)) +
geom_line(aes(colour = maxmin, alpha = maxmin, size = maxmin)) +
geom_abline(intercept = 0, slope = ev, linetype="dashed", size=0.5, color="red", alpha=.5) +
geom_hline(yintercept = 0, size=0.5, alpha=.5) +
xlab("Hours played") + ylab("Money (euros)") +
scale_color_manual(values=c("blue", "red", "grey")) +
theme_minimal(base_size=14) +
theme(legend.title = element_blank(),
legend.position = "top") +
scale_x_continuous(breaks = seq(0, rounds, by = 600),
labels=function(x)round(x/5/60, 1)) +
scale_alpha_manual(values = c(1, 1, .3)) +
scale_size_manual(values = c(1, 1, .5))
#labs(title = paste("Upswing proportion (SD): ", round(output[1], 3), "(", round(output[2], 3), ")"))
#Upswing visualization (not optimal yet!)
plot4 <- simulations.long %>%
# dplyr::mutate(slope_corrected = ifelse(is.na(slope_corrected), 0, slope_corrected)) %>% ## I'm switching back to numeric for testing purposes, fix later
na.omit() %>%
ggplot(aes(ID, value, group=key)) +
geom_line(aes(colour = slope_corrected), size=0.9) +
geom_abline(intercept = 0, slope = ev, linetype="dashed", size=0.5, color="red", alpha=.5) +
geom_hline(yintercept = 0, size=0.5, alpha=.5) +
xlab("Hours played") + ylab("Money (euros)") +
labs(color = "Streak strength") +
theme_minimal(base_size=14) +
theme(legend.position = "top") +
scale_alpha_manual(values = c(1, 1, .3)) +
scale_size_manual(values = c(1, 1, .5)) +
scale_color_gradient2(low="red", mid = "lightblue", high="blue") +
scale_x_continuous(breaks = seq(0, rounds, by = 600),
labels=function(x)round(x/5/60, 1))
#Add the below only if upswing_detector is used!
# annotate("text", x = 550, y = 60,
#          label = paste("Winning streaks:", round(simulations.long$upswing_prop[1], 3)*100, "%"))
# # annotate("text", x = 550, y = 60,
# #          label = paste("Winning streaks:", round(simulations.long$upswing_prop[1], 3)*100, "%",
# #                        round(simulations.long$upswing_prop[rounds+1], 3)*100, "%")) #This is an ugly fix, not for long-term use
if (topbottom == F) {
return(winners)
}
else {
return(plot3) #or upswing_detector()
#plot for problem gambling risk plot (ALPHA VERSION!), plot2 for top and bottom, winners for number of winners at end. Visualizations work with "plot2". Note that the code may break (update to fix this is pending) if two players have idential wins or losses at the top or bottom (this is quite rare but may happen). upswing_detector() for mean length and sd of average upswings (defined as upwards trending streak of 2 hours)
}
}
casino_simulator(3000, 100, F, "low")
casino_simulator(3000, 100, T, "low")
casino_simulator <- function(rounds, players, topbottom = F, volatility = "low") {
simulations = data.frame(nrow = 0)
if (volatility=="low") {
payout <- c(100, 50, 30, 15, 8, 7, 3, 2, 0) - 1
probability <- c(0.002, 0.011, 0.236, 1.151, 1.101, 1.123, 7.445, 12.928, 76.003)/100
ev <- sum(payout*probability) #ev = -0.10045
}
else if (volatility=="med") {
payout <- c(500, 65, 45, 13, 7, 6, 3, 2, 0) - 1
probability <- c(0.002, 0.011, 0.236, 1.151, 1.101, 1.123, 7.445, 12.928, 76.003)/100
ev <- sum(payout*probability) #ev = -0.10066
}
else {
payout <- c(2000, 50, 33, 14, 7, 5, 3, 2, 0) - 1
probability <- c(0.002, 0.011, 0.236, 1.151, 1.101, 1.123, 7.445, 12.928, 76.003)/100
ev <- sum(payout*probability) #ev = -0.10035
}
for (i in 1:players) {
test <- sample(payout, rounds, replace=TRUE, prob=probability)
test <- data.frame(run = test)
names(test)[1] <- i
simulations <- cbind(simulations, cumsum(test))
simulations$nrow <- NULL
}
max_value <- which(tail(simulations, 1) == max(tail(simulations, 1))) # Among the last row, which column has the highest value
min_value <- which(tail(simulations, 1) == min(tail(simulations, 1))) # Among the last row, which column has the lowest value
#How many are winning at the end
winners <- length(which(tail(simulations, 1) > 0))
simulations$ID <- seq.int(nrow(simulations))
simulations.long <- simulations %>%
gather(key, value, -ID)
#Upswing calculations using custom sliding-window regression (width-300 i.e. 1 hour)
simulations.long <- simulations.long %>% group_by(key) %>% dplyr::mutate(id = seq(1:n()))
upswing_detector <- function(window_width = 300, fidelity=1) { #window_width = 300 = 1 hour as a definition of upswing range
estimates_slope <- list()
counter = 0
for (x in 1:length(unique(simulations.long$key))) { #iterate through all players
for (i in seq(1, length(unique(simulations.long$id))+1-window_width, by = fidelity)) { #how many sliding windows fit within the sample, fidelity to speed calculation
temp <- subset(simulations.long, key==x & id >= i & id < i+window_width) #subset based on selected window width
temp_model <- lm(value ~ id, data=temp)
counter = counter + 1
estimates_slope[[counter]] <- coef(summary(temp_model))[2,1]
}
}
estimates_slope <- as.data.frame(unlist(estimates_slope))
estimates_slope <- estimates_slope %>%
dplyr::mutate(ID=rep(1:players, each=(length(unique(simulations.long$id))-window_width) / fidelity + 1)) # +1 before -window_width removed since otherwise doesn't work with fidelity=1 for some reason
names(estimates_slope)[1] <- "slope"
# Calculate proportion of upswings (vs. downswings) for all players, then obtain mean and sd across players, as well as maximum streak length with sd
output1 <- estimates_slope %>%
group_by(ID) %>%
dplyr::mutate(positive = ifelse(slope > 0, 1, 0),
run_length = rep(rle(positive)$lengths, rle(positive)$lengths)) %>%
dplyr::summarize(pos_prop = mean(positive),
max_run = max(run_length)) %>%
ungroup() %>%
dplyr::summarize(mean_grand_prop = mean(pos_prop),
sd_grand_prop = sd(pos_prop),
mean_run = mean(max_run),
sd_run = sd(max_run))
output2 <- estimates_slope %>%
group_by(ID) %>%
dplyr::mutate(numb = 1:n(), upswing = factor(ifelse(slope > 0, "Upswing", "Downswing"))) %>%
ggplot(aes(numb, slope, color=upswing)) +
geom_line(aes(group=1)) +
#facet_wrap("ID", scales="free") +
labs(color=NULL, x = "Hours played", y = "Slope") +
scale_color_manual(values=c("red", "blue")) +
scale_x_continuous(breaks = seq(0, (rounds-window_width)/10, by = 60),
labels=function(x)round(x/5/6 +1, 1)) + #+1 jotta saadaan tasattua normiplotin kanssa
theme_minimal(base_size=14) +
theme(legend.position="bottom")
output3 <- estimates_slope %>%
rename(key = ID) %>%
group_by(key) %>%
dplyr::mutate(key = as.character(key), ID = 1:n(), upswing = factor(ifelse(lag(slope, window_width/2) > 0, "Upswing", "Downswing")),
slope_corrected = lag(slope, window_width/2),
upswing_prop = mean(as.numeric(upswing)-1, na.rm=T)) #difficult to visualize upswings!! (this is not optimal, using lag() since the last 300 (window length) observations are missing by design)
#return(ggarrange(output2, plot3))
return(output3) #for colored visulaization of upswing
#return(output1) #for upswing proportion calculations
}
# !!!!!uncomment below to be able to use plot4!!!!!
#simulations.long <- simulations.long %>% left_join(upswing_detector())
#This was for testing whether the upswing detector works (un-comment below, and add "labs(title = output)" to plot3)
#output <- upswing_detector()
# Plot only the top and bottom "players"
# Note, for animations, the coloring is sensitive to alphabetical order of the key-factor labels!
plot2 <- simulations.long %>%
dplyr::filter(key == max_value | key == min_value) %>%
dplyr::mutate(key = factor(key, levels = c(max_value, min_value),
labels = c("Luckiest\nplayer", "Unluckiest\nplayer"))) %>%
ggplot(aes(ID, value, group=key)) +
geom_line(aes(colour = key)) +
geom_abline(intercept = 0, slope = ev, linetype="dashed", size=0.5, color="red", alpha=.5) +
geom_hline(yintercept = 0, size=0.5, alpha=.5) +
xlab("Hours played") + ylab("Money (euros)") +
theme_minimal(base_size=14) +
scale_x_continuous(breaks = seq(0, rounds, by = 600), # If <0 hour is visualized, the x-axis will not show correctly
labels=function(x)round(x/5/60, 1)) +
guides(color="none")
# Combined plot
# (code may fail if there are 3 or more identical values (shared bottom or top))
plot3 <- simulations.long %>%
dplyr::mutate(maxmin = case_when(key == max_value ~ "Luckiest\nplayer",
key == min_value ~ "Unluckiest\nplayer",
TRUE ~ "Others"),
maxmin = factor(maxmin, levels = c("Luckiest\nplayer", "Unluckiest\nplayer", "Others"))) %>%
ggplot(aes(ID, value, group=key)) +
geom_line(aes(colour = maxmin, alpha = maxmin, size = maxmin)) +
geom_abline(intercept = 0, slope = ev, linetype="dashed", size=0.5, color="red", alpha=.5) +
geom_hline(yintercept = 0, size=0.5, alpha=.5) +
xlab("Hours played") + ylab("Money (euros)") +
scale_color_manual(values=c("blue", "red", "grey")) +
theme_minimal(base_size=14) +
theme(legend.title = element_blank(),
legend.position = "top") +
scale_x_continuous(breaks = seq(0, rounds, by = 600),
labels=function(x)round(x/5/60, 1)) +
scale_alpha_manual(values = c(1, 1, .3)) +
scale_size_manual(values = c(1, 1, .5))
#labs(title = paste("Upswing proportion (SD): ", round(output[1], 3), "(", round(output[2], 3), ")"))
#Upswing visualization (not optimal yet!)
plot4 <- simulations.long %>%
# dplyr::mutate(slope_corrected = ifelse(is.na(slope_corrected), 0, slope_corrected)) %>% ## I'm switching back to numeric for testing purposes, fix later
na.omit() %>%
ggplot(aes(ID, value, group=key)) +
geom_line(aes(colour = slope_corrected), size=0.9) +
geom_abline(intercept = 0, slope = ev, linetype="dashed", size=0.5, color="red", alpha=.5) +
geom_hline(yintercept = 0, size=0.5, alpha=.5) +
xlab("Hours played") + ylab("Money (euros)") +
labs(color = "Streak strength") +
theme_minimal(base_size=14) +
theme(legend.position = "top") +
scale_alpha_manual(values = c(1, 1, .3)) +
scale_size_manual(values = c(1, 1, .5)) +
scale_color_gradient2(low="red", mid = "lightblue", high="blue") +
scale_x_continuous(breaks = seq(0, rounds, by = 600),
labels=function(x)round(x/5/60, 1))
#Add the below only if upswing_detector is used!
# annotate("text", x = 550, y = 60,
#          label = paste("Winning streaks:", round(simulations.long$upswing_prop[1], 3)*100, "%"))
# # annotate("text", x = 550, y = 60,
# #          label = paste("Winning streaks:", round(simulations.long$upswing_prop[1], 3)*100, "%",
# #                        round(simulations.long$upswing_prop[rounds+1], 3)*100, "%")) #This is an ugly fix, not for long-term use
if (topbottom == F) {
return(plot2) #winners for number of winners
}
else {
return(plot3) #or upswing_detector()
#plot for problem gambling risk plot (ALPHA VERSION!), plot2 for top and bottom, winners for number of winners at end. Visualizations work with "plot2". Note that the code may break (update to fix this is pending) if two players have idential wins or losses at the top or bottom (this is quite rare but may happen). upswing_detector() for mean length and sd of average upswings (defined as upwards trending streak of 2 hours)
}
}
casino_simulator(3000, 100, F, "low")
casino_simulator <- function(rounds, players, topbottom = F, volatility = "low") {
simulations = data.frame(nrow = 0)
if (volatility=="low") {
payout <- c(100, 50, 30, 15, 8, 7, 3, 2, 0) - 1
probability <- c(0.002, 0.011, 0.236, 1.151, 1.101, 1.123, 7.445, 12.928, 76.003)/100
ev <- sum(payout*probability) #ev = -0.10045
}
else if (volatility=="med") {
payout <- c(500, 65, 45, 13, 7, 6, 3, 2, 0) - 1
probability <- c(0.002, 0.011, 0.236, 1.151, 1.101, 1.123, 7.445, 12.928, 76.003)/100
ev <- sum(payout*probability) #ev = -0.10066
}
else {
payout <- c(2000, 50, 33, 14, 7, 5, 3, 2, 0) - 1
probability <- c(0.002, 0.011, 0.236, 1.151, 1.101, 1.123, 7.445, 12.928, 76.003)/100
ev <- sum(payout*probability) #ev = -0.10035
}
for (i in 1:players) {
test <- sample(payout, rounds, replace=TRUE, prob=probability)
test <- data.frame(run = test)
names(test)[1] <- i
simulations <- cbind(simulations, cumsum(test))
simulations$nrow <- NULL
}
max_value <- which(tail(simulations, 1) == max(tail(simulations, 1))) # Among the last row, which column has the highest value
min_value <- which(tail(simulations, 1) == min(tail(simulations, 1))) # Among the last row, which column has the lowest value
#How many are winning at the end
winners <- length(which(tail(simulations, 1) > 0))
simulations$ID <- seq.int(nrow(simulations))
simulations.long <- simulations %>%
gather(key, value, -ID) %>%
group_by(key) %>%
dplyr::mutate(profit = factor(ifelse(value > 0, 1, 0)), # Is the player winning or not
profitriskcumsum = cumsum(as.numeric(profit)-1), # cumulative number of rounds in profit
randomrisk = which(sample(c(0,1), n(), prob=c(.9999603, 1-.9999603), replace=T) == 1)[1], #among n(), produce a moment when problem gambling starts. Probability: 84 (one full week) hours of playing one has 50% chance of becoming "problem gambler" (or "high risk gambler"). 84 * 60 minutes * 5 rounds = 25200 (1- 1/25200 =  .9999603)
randomrisk = ifelse(is.na(randomrisk), n(), randomrisk), #if prob gambling doesn't start, replace NA with total length of sample
randomrisk = c(rep(0, randomrisk[1]), rep(1, n() - randomrisk[1])), #vector with 0s until problem gambling starts (1s); have to index at 1 since rep-counts argument is a vector of identical values
problem = factor(case_when(profitriskcumsum > 900 | randomrisk == 1 ~ sample(c("Not at risk", "At risk"), 1, prob=c(.5, .5)), # when winning too much, 50% chance of becoming probl. gambl. OR random risk of becoming problem gambler
TRUE ~ "Not at risk"))) %>%
ungroup()
#Upswing calculations using custom sliding-window regression (width-300 i.e. 1 hour)
simulations.long <- simulations.long %>% group_by(key) %>% dplyr::mutate(id = seq(1:n()))
upswing_detector <- function(window_width = 300, fidelity=1) { #window_width = 300 = 1 hour as a definition of upswing range
estimates_slope <- list()
counter = 0
for (x in 1:length(unique(simulations.long$key))) { #iterate through all players
for (i in seq(1, length(unique(simulations.long$id))+1-window_width, by = fidelity)) { #how many sliding windows fit within the sample, fidelity to speed calculation
temp <- subset(simulations.long, key==x & id >= i & id < i+window_width) #subset based on selected window width
temp_model <- lm(value ~ id, data=temp)
counter = counter + 1
estimates_slope[[counter]] <- coef(summary(temp_model))[2,1]
}
}
estimates_slope <- as.data.frame(unlist(estimates_slope))
estimates_slope <- estimates_slope %>%
dplyr::mutate(ID=rep(1:players, each=(length(unique(simulations.long$id))-window_width) / fidelity + 1)) # +1 before -window_width removed since otherwise doesn't work with fidelity=1 for some reason
names(estimates_slope)[1] <- "slope"
# Calculate proportion of upswings (vs. downswings) for all players, then obtain mean and sd across players, as well as maximum streak length with sd
output1 <- estimates_slope %>%
group_by(ID) %>%
dplyr::mutate(positive = ifelse(slope > 0, 1, 0),
run_length = rep(rle(positive)$lengths, rle(positive)$lengths)) %>%
dplyr::summarize(pos_prop = mean(positive),
max_run = max(run_length)) %>%
ungroup() %>%
dplyr::summarize(mean_grand_prop = mean(pos_prop),
sd_grand_prop = sd(pos_prop),
mean_run = mean(max_run),
sd_run = sd(max_run))
output2 <- estimates_slope %>%
group_by(ID) %>%
dplyr::mutate(numb = 1:n(), upswing = factor(ifelse(slope > 0, "Upswing", "Downswing"))) %>%
ggplot(aes(numb, slope, color=upswing)) +
geom_line(aes(group=1)) +
#facet_wrap("ID", scales="free") +
labs(color=NULL, x = "Hours played", y = "Slope") +
scale_color_manual(values=c("red", "blue")) +
scale_x_continuous(breaks = seq(0, (rounds-window_width)/10, by = 60),
labels=function(x)round(x/5/6 +1, 1)) + #+1 jotta saadaan tasattua normiplotin kanssa
theme_minimal(base_size=14) +
theme(legend.position="bottom")
output3 <- estimates_slope %>%
rename(key = ID) %>%
group_by(key) %>%
dplyr::mutate(key = as.character(key), ID = 1:n(), upswing = factor(ifelse(lag(slope, window_width/2) > 0, "Upswing", "Downswing")),
slope_corrected = lag(slope, window_width/2),
upswing_prop = mean(as.numeric(upswing)-1, na.rm=T)) #difficult to visualize upswings!! (this is not optimal, using lag() since the last 300 (window length) observations are missing by design)
#return(ggarrange(output2, plot3))
return(output3) #for colored visulaization of upswing
#return(output1) #for upswing proportion calculations
}
# !!!!!uncomment below to be able to use plot4!!!!!
#simulations.long <- simulations.long %>% left_join(upswing_detector())
#This was for testing whether the upswing detector works (un-comment below, and add "labs(title = output)" to plot3)
#output <- upswing_detector()
#THIS IS AN ALPHA VERSION: Illustrations of "at risk" players based on time as a winner and length of play
# plot <- simulations.long %>%
#   dplyr::mutate(problem = fct_relevel(problem, "Not at risk")) %>% #force factor level order (simulations mess this up every now and then...)
#   ggplot(aes(ID, value, group=key)) + # group=key here required for complex animation
#   geom_line(aes(colour = problem, size = problem)) +
#   geom_abline(intercept = 0, slope = ev, linetype="dashed", size=0.5, color="red", alpha=.5) +
#   geom_hline(yintercept = 0, size=0.5, alpha=.5) +
#   xlab("Hours played") + ylab("Money (euros)") +
#   theme_minimal(base_size=14) +
#   scale_x_continuous(breaks = seq(0, rounds, by = 600), #by = 600 on by 2 hours (i.e. 600 rounds / 5 / 60)
#                      labels=function(x)round(x/5/60, 1)) +
#   theme(legend.title = element_blank(),
#         legend.position = "top") +
#   scale_color_manual(values=c("lightblue", "red")) +
#   scale_size_manual(values = c(.3, 1))
#   # guides(color="none")
# Plot only the top and bottom "players"
# Note, for animations, the coloring is sensitive to alphabetical order of the key-factor labels!
plot2 <- simulations.long %>%
dplyr::filter(key == max_value | key == min_value) %>%
dplyr::mutate(key = factor(key, levels = c(max_value, min_value),
labels = c("Luckiest\nplayer", "Unluckiest\nplayer"))) %>%
ggplot(aes(ID, value, group=key)) +
geom_line(aes(colour = key)) +
geom_abline(intercept = 0, slope = ev, linetype="dashed", size=0.5, color="red", alpha=.5) +
geom_hline(yintercept = 0, size=0.5, alpha=.5) +
xlab("Hours played") + ylab("Money (euros)") +
theme_minimal(base_size=14) +
scale_x_continuous(breaks = seq(0, rounds, by = 600), # If <0 hour is visualized, the x-axis will not show correctly
labels=function(x)round(x/5/60, 1)) +
guides(color="none")
# Combined plot
# (code may fail if there are 3 or more identical values (shared bottom or top))
plot3 <- simulations.long %>%
dplyr::mutate(maxmin = case_when(key == max_value ~ "Luckiest\nplayer",
key == min_value ~ "Unluckiest\nplayer",
TRUE ~ "Others"),
maxmin = factor(maxmin, levels = c("Luckiest\nplayer", "Unluckiest\nplayer", "Others"))) %>%
ggplot(aes(ID, value, group=key)) +
geom_line(aes(colour = maxmin, alpha = maxmin, size = maxmin)) +
geom_abline(intercept = 0, slope = ev, linetype="dashed", size=0.5, color="red", alpha=.5) +
geom_hline(yintercept = 0, size=0.5, alpha=.5) +
xlab("Hours played") + ylab("Money (euros)") +
scale_color_manual(values=c("blue", "red", "grey")) +
theme_minimal(base_size=14) +
theme(legend.title = element_blank(),
legend.position = "top") +
scale_x_continuous(breaks = seq(0, rounds, by = 600),
labels=function(x)round(x/5/60, 1)) +
scale_alpha_manual(values = c(1, 1, .3)) +
scale_size_manual(values = c(1, 1, .5))
#labs(title = paste("Upswing proportion (SD): ", round(output[1], 3), "(", round(output[2], 3), ")"))
#Upswing visualization (not optimal!)
plot4 <- simulations.long %>%
# dplyr::mutate(slope_corrected = ifelse(is.na(slope_corrected), 0, slope_corrected)) %>% ## I'm switching back to numeric for testing purposes, fix later
na.omit() %>%
ggplot(aes(ID, value, group=key)) +
geom_line(aes(colour = slope_corrected), size=0.9) +
geom_abline(intercept = 0, slope = ev, linetype="dashed", size=0.5, color="red", alpha=.5) +
geom_hline(yintercept = 0, size=0.5, alpha=.5) +
xlab("Hours played") + ylab("Money (euros)") +
labs(color = "Streak strength") +
theme_minimal(base_size=14) +
theme(legend.position = "top") +
scale_alpha_manual(values = c(1, 1, .3)) +
scale_size_manual(values = c(1, 1, .5)) +
scale_color_gradient2(low="red", mid = "lightblue", high="blue") +
scale_x_continuous(breaks = seq(0, rounds, by = 600),
labels=function(x)round(x/5/60, 1))
#Add the below only if upswing_detector is used!
# annotate("text", x = 550, y = 60,
#          label = paste("Winning streaks:", round(simulations.long$upswing_prop[1], 3)*100, "%"))
# # annotate("text", x = 550, y = 60,
# #          label = paste("Winning streaks:", round(simulations.long$upswing_prop[1], 3)*100, "%",
# #                        round(simulations.long$upswing_prop[rounds+1], 3)*100, "%")) #This is an ugly fix, not for long-term use
if (topbottom == F) {
return(plot2) #winners for number of winners
}
else {
return(plot3) #or upswing_detector()
#plot for problem gambling risk plot (ALPHA VERSION!), plot2 for top and bottom, winners for number of winners at end. Visualizations work with "plot2". Note that the code may break (update to fix this is pending) if two players have idential wins or losses at the top or bottom (this is quite rare but may happen). upswing_detector() for mean length and sd of average upswings (defined as upwards trending streak of 2 hours)
}
}
casino_simulator(3000, 100, T, "low")
casino_simulator(3000, 100, F, "low")
dev.off()
2950/1.25
2950*0.25
2950-727.5
2950-727.5
2950*0.75
2600+2000
4600+3200
